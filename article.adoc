= KubeVirt

KubeVirt - это надстройка для управления виртуальными машинами для Kubernetes. +
Цель состоит в том, чтобы обеспечить общую основу для решений виртуализации поверх Kubernetes. +

Kubernetes допускает расширения своей архитектуры с помощью пользовательских ресурсов, которые добавляют новую конечную точку в API Kubernetes, которая хранит и извлекает объекты API коллекции определенного типа. +
Пользовательские ресурсы сами по себе позволяют только хранить и извлекать структурированные данные; для добавления бизнес-логики и специфической функциональности необходимы пользовательские контроллеры. +
Контроллеры - это клиенты API-сервера Kubernetes, которые обычно считывают спецификацию объекта, возможно, выполняют какие-то действия, а затем обновляют статус объекта.

KubeVirt использует CRD, контроллеры и другие функции Kubernetes для представления традиционных виртуальных машин и управления ими бок о бок с контейнерами.

Основным CRD KubeVirt является ресурс VirtualMachine (VM), который управляет жизненным циклом объекта VirtualMachineInstance


===== На сегодняшний день KubeVirt можно использовать для:
- Создание виртуальной машины
- Запуска виртуальной машины
- Остановки виртуальной машины
- Удаление виртуальной машины

==== Архиктера:

KubeVirt  построен с использованием сервис-ориентированной архитектуры и шаблона хореографии. +

Пользователи, которым требуются службы виртуализации, обращаются к API виртуализации, который, в свою очередь, обращается к кластеру Kubernetes, чтобы запланировать запрошенные экземпляры виртуальных машин (VMIS). Планирование, создание сетей и хранение - все это делегировано Kubernetes, в то время как KubeVirt обеспечивает функциональность виртуализации.

KubeVirt обеспечивает три вещи для обеспечения новой функциональности:

- Дополнительные типы - (CRD)
- Дополнительные контроллеры для общекластерной логики, связанные с этими новыми типами
- Дополнительные демоны для специфичной для узла логики, связанной с новыми типами

KubeVirt предоставляет два типа машин: +

- VirtualMachine (VM) - виртуальная машина с сохранением состояния, которую можно останавливать и запускать, сохраняя данные и состояние виртуальной машины.
- VirtualMachineInstanceReplicaSet (VMIRS) - аналогично pods ReplicaSet, группе эфемерных виртуальных машин с аналогичной конфигурацией, определенной в шаблоне.

==== Структура:
KubeVirt состоит из набора сервисов:

===== virt-api-server
Сервер HTTP API, который служит точкой входа для всех потоков, связанных с виртуализацией.

===== VMI (CRD)
Определения VMI хранятся как пользовательские ресурсы внутри сервера API Kubernetes.

Определение VMI определяет все свойства самой виртуальной машины, например:

- Machine type
- CPU type
- Amount of RAM and vCPUs
- Number and type of NICs

===== virt-controller
С точки зрения высокого уровня virt-контроллер обладает всеми функциями виртуализации в масштабах всего кластера.
Этот контроллер отвечает за мониторинг VMI (CRs) и управление соответствующими модулями. В настоящее время контроллер позаботится о создании и управлении жизненным циклом модулей, связанных с объектами VMI.
Объект WMI всегда будет связан с pod в течение всего срока его службы.

===== virt-launcher
Для каждого объекта VMI создается один модуль. Основной контейнер этого модуля запускает компонент virtual launcher KubeVirt.

Kubernetes или kubelet не запускают саму виртуальную машину. Вместо этого демон на каждом хосте в кластере позаботится о запуске процесса VMI для каждого модуля, связанного с объектом VMI, всякий раз, когда он запланирован на хосте.

Основная цель модуля virt-launcher - предоставить с-группы и пространства имен, которые будут использоваться для размещения процесса VMI.

virt-обработчик сигнализирует virt-launcher о запуске VMI, передавая объект CRD VMI в virt-launcher. затем virt-launcher использует локальный экземпляр libvirtd в своем контейнере для запуска VMI. Оттуда virt-launcher отслеживает процесс VMI и завершает его после выхода из VMI.

Если среда выполнения Kubernetes пытается завершить работу модуля virtual launcher до завершения работы VMI, virtual launcher пересылает сигналы от Kubernetes процессу VMI и пытается отложить завершение работы модуля до успешного завершения работы VMI.

===== virt-handler

Это демон, который запускается на каждом узле Kubernetes. Он отвечает за мониторинг состояния виртуальных машин в соответствии с Kubernetes и обеспечение загрузки или остановки соответствующего домена libvirt соответствующим образом. Для выполнения этих операций у первого обработчика есть канал связи с каждым virtual launcher, который используется для управления жизненным циклом процесса qemu в модуле virtual launcher.

===== libvirtd
Экземпляр libvirtd присутствует в каждом модуле VMI. virt-launcher использует libvirt для управления жизненным циклом процесса VMI.

Перечисленные выше компоненты необходимы для обеспечения основных функций виртуализации в вашем кластере. Однако полнофункциональные виртуальные машины требуют большего, чем просто функциональность виртуализации. Помимо виртуализации, для полноценного использования им также требуется надежное хранилище и сетевые функции.

Компоненты, приведенные ниже, будут предоставлять эту дополнительную функциональность, если эта функциональность не предоставляется самим kubernetes.

===== Virtual Machines Instances¶
Тип VirtualMachineInstance концептуально состоит из двух частей:

Информация для принятия решений о планировании

Информация об API виртуальной машины

Каждый объект VirtualMachineInstance представляет собой один запущенный экземпляр виртуальной машины.

==== Сеть
KubeVirt стремится легко интегрироваться в сеть Kubernetes, при этом виртуальные машины подключаются к той же сети, что и модули,
используя те же ресурсы и те же API. Без каких-либо внешних расширений виртуальные машины в KubeVirt способны использовать pod-сеть,
службы или сетевые политики.


Сетевые бэкенды настраиваются в спецификации networks.
Сеть должна иметь уникальное имя. Дополнительные поля указывают, к какому логическому или физическому устройству относится сеть.

Каждая сеть должна объявить свой тип, определив одно из следующих полей:

- pod - Default Kubernetes network
- multus - Secondary network provided using Multus

Сетевые интерфейсы настраиваются в spec.domain.devices.interfaces. Они описывают свойства виртуальных интерфейсов как "видимые"
внутри гостевых экземпляров. Один и тот же сетевой сервер может быть подключен к виртуальной машине несколькими различными способами,
каждый из которых имеет свои собственные гарантии подключения и характеристики.

Каждый интерфейс должен объявлять свой тип, определяя одно из следующих полей:
bridge - Connect using a linux bridge

- slirp - Connect using QEMU user networking mode

- sriov - Pass through a SR-IOV PCI device via vfio

- masquerade - Connect using Iptables rules to nat the traffic

==== Эмуляция программного обеспечения
По умолчанию KubeVirt использует устройство /dev/kvm для включения аппаратной эмуляции.

==== Cloud-Init

KubeVirt поддерживает возможность назначить сценарий запуска экземпляру VirtualMachineInstance, который выполняется автоматически при инициализации виртуальной машины.

Эти сценарии обычно используются для автоматизации ввода пользователей и SSH-ключей в виртуальные машины, чтобы обеспечить удаленный доступ к машине. Например, сценарий запуска можно использовать для ввода учетных данных в виртуальную машину, что позволяет заданию Ansible, выполняемому на удаленном хосте, получать доступ к виртуальной машине и предоставлять ее.

Однако сценарии запуска не ограничены каким-либо конкретным вариантом использования. Они могут быть использованы для запуска любого произвольного скрипта в виртуальной машине при загрузке.
Cloud-Init - это проект, который стандартизирует методы ввода данных в облачные виртуальные машины при запуске. Данные обычно включают метаданные и пользовательские данные

Метаданные динамически генерируются облачным провайдером и содержат информацию об уникальном экземпляре.

Пользовательские данные - это данные конфигурации VMI, предоставленные пользователем, которые выполняются при запуске экземпляра VMI.

==== NoCloud Data Source
KubeVirt поддерживает облачные источники данных "NoCloud" и "ConfigDrive", которые включают в себя внедрение сценариев запуска в экземпляр виртуальной машины с использованием эфемерного диска. Виртуальные машины с установленным пакетом cloud-init обнаружат временный диск и выполнят пользовательские скрипты пользовательских данных при загрузке.
Источник данных NoCloud включает в себя создание iso с пользовательскими данными и метаданными в нем и прикрепление этого iso к экземпляру VMI. Проект fedora-atomic поддерживает этот источник данных для своих изображений VMI.

Чтобы связать пользовательские данные с экземпляром VMI с использованием источника данных NoCloud, все, что нужно сделать пользователям, это base64 закодировать информацию о пользовательских данных в определение VMI.

==== CDI
Containerized-Data-Importer (CDI) - это надстройка для управления постоянным хранилищем для Kubernetes. Его основная цель - предоставить декларативный способ создания дисков виртуальных машин на PVCS для виртуальных машин Libvirt

CDI работает со стандартными основными ресурсами Kubernetes и не зависит от устройства хранения, хотя его основной задачей является создание образов дисков для Kubevirt, он также полезен вне контекста Kubevirt для инициализации ваших томов Kubernetes данными.

CDI включает в себя CustomResourceDefinition (CRD), который предоставляет объект типа DataVolume. DataVolume является абстракцией поверх стандартного Kubernetes PVC и может использоваться для автоматизации создания и заполнения PVC данными.

===== Импорт из URL
Этот метод выбирается при создании объема данных с использованием http-источника. CDI заполнит том с помощью модуля, который будет загружаться с указанного URL-адреса и обрабатывать содержимое в соответствии с настройкой ContentType (см. ниже). Можно настроить базовую аутентификацию с использованием секрета и указать пользовательские сертификаты TLS в ConfigMap.

===== Импорт из реестра контейнеров
Когда у тома данных есть источник реестра, CDI заполнит том диском-контейнером, загруженным с указанного URL-адреса изображения. Единственным допустимым типом содержимого для этого источника является kubevirt, а образ должен быть диском-контейнером. Более подробную информацию можно найти здесь.

===== Клонированиие другой PVC
Чтобы клонировать PVC, создайте объем данных с источником пвх и укажите пространство имен и имя исходного PVC. CDI попытается эффективно клонировать PVC, используя серверную часть хранилища, если это возможно. В противном случае данные будут переданы целевому серверу с использованием защищенного TLS соединения между двумя модулями в кластерной сети. Более подробную информацию можно найти здесь.

===== Загрузка с клиента
Чтобы загрузить данные в PVC с клиентского компьютера, сначала создайте DataVolume с источником загрузки. CDI подготовится к приему данных через прокси-сервер загрузки, который передаст данные от аутентифицированного клиента в модуль, который заполнит PVC в соответствии с настройкой ContentType. Чтобы отправить данные на прокси-сервер загрузки, у вас должен быть действительный UploadToken. Подробности смотрите в документации по загрузке.

===== Импорт из VMware
Диски могут быть импортированы из VMware с помощью источника vddk. CDI перенесет диски, используя учетные данные vCenter/ESX API и предоставленный пользователем образ, содержащий не подлежащую распространению библиотеку VDDK.

==== Маленький туториал
```
export VERSION=$(curl -s https://api.github.com/repos/kubevirt/kubevirt/releases | grep tag_name | grep -v -- '-rc' | sort -r | head -1 | awk -F': ' '{print $2}' | sed 's/,//' | xargs)
```

```
kubectl create -f https://github.com/kubevirt/kubevirt/releases/download/${VERSION}/kubevirt-operator.yaml
```

```
kubectl create -f https://github.com/kubevirt/kubevirt/releases/download/${VERSION}/kubevirt-cr.yaml
```

```
wget https://kubevirt.io/labs/manifests/vm.yaml
```

```
kubectl get vms
```

```
# Start the virtual machine:
kubectl virt start testvm

# Stop the virtual machine:
kubectl virt stop testvm

virtctl console testvm
```

```
cirros : gocubsgo
```